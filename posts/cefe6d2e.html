

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head><!-- hexo injector head_begin start -->
<link rel="stylesheet" href="/css/custom-theme.css">
<link rel="stylesheet" href="/css/animation.css">
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<!-- hexo injector head_begin end -->
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/bubao/picgo_db_tiny/logo/mylogo.svg">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/bubao/picgo_db_tiny/logo/mylogo.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="一念">
  <meta name="keywords" content="">
  
    <meta name="description" content="1.abstract 解释：抽象，抽象的用法：类修饰符的一种，可以用来修饰类，方法，被修饰的类不能够实例化（即不能用** new **关键字得到对象），被修饰的方法不能够实现。一个抽象类中不一定要有抽象方法，但是一个类里面有抽象方法就一定是抽象类。如果由类要继承抽象类的话，必须要实现里面的抽象方法。构造方法和静态方法不可以修饰为抽象。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 关键字总结">
<meta property="og:url" content="https://bubao.github.io/posts/cefe6d2e.html">
<meta property="og:site_name" content="瓦猫杂货铺">
<meta property="og:description" content="1.abstract 解释：抽象，抽象的用法：类修饰符的一种，可以用来修饰类，方法，被修饰的类不能够实例化（即不能用** new **关键字得到对象），被修饰的方法不能够实现。一个抽象类中不一定要有抽象方法，但是一个类里面有抽象方法就一定是抽象类。如果由类要继承抽象类的话，必须要实现里面的抽象方法。构造方法和静态方法不可以修饰为抽象。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-07-29T15:08:30.000Z">
<meta property="article:modified_time" content="2025-05-18T07:26:40.438Z">
<meta property="article:author" content="一念">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java 关键字总结 - 瓦猫杂货铺</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_2341296_qq5e51uzpqa.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"bubao.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"✦","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/global.js"></script>
<script src="/js/cat/custom-utils.js"></script>
<script src="/js/cat/onClick.js"></script>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>瓦猫杂货铺</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/zitie/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>字帖</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/bubao/picgo_db_tiny/img/20210121213449.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java 关键字总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2016-07-29 23:08" pubdate>
          2016年7月29日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          98 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java 关键字总结</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="1-abstract"><a href="#1-abstract" class="headerlink" title="1.abstract"></a>1.abstract</h2><blockquote>
<p>解释：抽象，抽象的<br>用法：类修饰符的一种，可以用来修饰类，方法，被修饰的类不能够实例化（即不能用** new **关键字得到对象），被修饰的方法不能够实现。一个抽象类中不一定要有抽象方法，但是一个类里面有抽象方法就一定是抽象类。如果由类要继承抽象类的话，必须要实现里面的抽象方法。构造方法和静态方法不可以修饰为抽象。<span id="more"></span></p>
</blockquote>
<p><strong>abstract</strong> 关键字可以修改类或方法。</p>
<p><strong>abstract</strong> 类可以扩展（增加子类），但不能直接实例化。</p>
<p>abstract 方法不在声明它的类中实现，但必须在某个子类中重写。</p>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>采用 <strong>abstract</strong> 方法的类本来就是抽象类，并且必须声明为 <strong>abstract</strong>。<br><strong>abstract</strong> 类不能实例化。<br>仅当 <strong>abstract</strong> 类的子类实现其超类的所有 <strong>abstract</strong> 方法时，才能实例化 <strong>abstract</strong> 类的子类。这种类称为具体类，以区别于 <strong>abstract</strong> 类 。<br>如果 <strong>abstract</strong> 类的子类没有实现其超类的所有 <strong>abstract</strong> 方法，该子类也是 <strong>abstract</strong> 类。<br>abstract 关键字不能应用于 <strong>static</strong>、<strong>private</strong> 或 <strong>final</strong> 方法，因为这些方法不能被重写，因此，不能在子类中实现。<br><strong>final</strong> 类的方法都不能是 <strong>abstract</strong>，因为 <strong>final</strong> 类不能有子类。</p>
</blockquote>
<ol>
<li><strong>abstract <strong>抽象用在类的声明中来指明一个类是不能被实例化的，但是可以被其他类继承。一个抽象类可以使用抽象方法，抽象方法不需要实现，但是需要在子类中被实现。它的用途是向子类提供通用的信息。抽象类可以包含正常的类包含的任何东西，也就是说，类和实例变量，以及带有任何修饰词的方法。只有抽象类可能有抽象方法。如果一个不是抽象的类包含一个抽象方法，那么将会出现编译错误。<br>例子：如果下列的一个成立，那么一个有抽象方法：<br>a. 它显式的声明了一个</strong> abstract <strong>方法。<br>b. 它从它的直接父类继承了一个抽象方法。<br>c. 一个直接的类的父借口声明或继承了它的一个方法（这因此必须是</strong> abstract</strong>）</li>
<li>如果用户声明** private**,<strong>static</strong>, 和** final <strong>方法为 abstarct，编译错误将出现。不可能重设一个</strong> private <strong>方法，因为一个</strong> abstarct private <strong>永远不能被实现。</strong>static <strong>方法总是可用的，因此必须有一个实现；</strong>static abstract <strong>将永远没有实现。</strong>final <strong>方法不能被重设，因此不回有</strong> final abstract **方法的实现。</li>
</ol>
<h2 id="2-boolean"><a href="#2-boolean" class="headerlink" title="2.boolean"></a>2.boolean</h2><blockquote>
<p>解释：数据类型，布尔型，它的取值只能为** true <strong>或者</strong> false<strong>。<br>用法：用来定义临时变量、形参、属性的数据类型。格式如下：</strong>boolean 【变量名、形参名、属性名】**<br>变量的值可以是 <strong>true</strong> 或 <strong>false</strong>。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (valid) &#123;<br>	&lt;statement&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>boolean</strong> 变量只能以 <strong>true</strong> 或 <strong>false</strong> 作为值。<br><strong>boolean</strong> 不能与数字类型相互转换。<br>包含 <strong>boolean</strong> 操作数的表达式只能包含 <strong>boolean</strong> 操作数。<br><strong>boolean</strong> 类是 <strong>boolean</strong> 原始类型的包装对象类。</p>
</blockquote>
<h2 id="3-break"><a href="#3-break" class="headerlink" title="3.break"></a>3.break</h2><blockquote>
<p>用法：用于提前退出 <strong>for</strong>、<strong>while</strong> 或 <strong>do</strong> 循环，或者在 <strong>switch</strong> 语句中用来结束 <strong>case</strong> 块。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;max; i++) &#123;<br>	<span class="hljs-keyword">if</span> (&lt;loop finished early&gt;) &#123;<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> &lt;some value&gt;;<br><span class="hljs-keyword">switch</span> (type) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>	&lt;statement&gt;<br>	<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>	&lt;statement&gt;<br>	<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>	&lt;statement&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>break</strong> 总是退出最深层的 <strong>while</strong>、<strong>for</strong>、<strong>do</strong> 或 <strong>switch</strong> 语句。</p>
</blockquote>
<h2 id="4-byte"><a href="#4-byte" class="headerlink" title="4.byte"></a>4.byte</h2><blockquote>
<p>解释：数据类型，字节型<br>用法：用来定义临时变量、形参、属性的数据类型。格式如下：<strong>byte 【变量名、形参名、属性名】</strong></p>
</blockquote>
<p><strong>byte</strong> 是 Java 原始类型。<br><strong>byte</strong> 可存储在 <strong>[-128, 127]</strong> 范围以内的整数值。</p>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">124</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>byte</strong> 类是 <strong>byte</strong> 原始类型的包装对象类。它定义代表此类型的值的范围的 **MIN_VALUE **和 **MAX_VALUE **常量。<br>Java 中的所有整数值都是 32 位的 <strong>int</strong> 值，除非值后面有 <strong>l</strong> 或 <strong>L</strong>（如 235L），这表示该值应解释为 <strong>long</strong>。</p>
</blockquote>
<h2 id="5-case"><a href="#5-case" class="headerlink" title="5.case"></a>5.case</h2><blockquote>
<p>用法：用来标记 <strong>switch</strong> 语句中的每个分支。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> &lt;some value&gt;;<br><span class="hljs-keyword">switch</span> (arg) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>	&lt;statements&gt;<br>	<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>	&lt;statements&gt;<br>	<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>	&lt;statements&gt;<br>	<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>-注释-<br><strong>case</strong> 块没有隐式结束点。<strong>break</strong> 语句通常在每个 <strong>case</strong> 块末尾使用，用于退出 <strong>switch</strong> 语句。<br>如果没有 <strong>break</strong> 语句，执行流将进入所有后面的 <strong>case</strong> 和&#x2F;或 <strong>default</strong> 块。</p>
</blockquote>
<h2 id="6-catch"><a href="#6-catch" class="headerlink" title="6.catch"></a>6.catch</h2><blockquote>
<p>解释：捕捉，捕获<br>用法：当发现被监视的代码中有异常出现的时候，**catch <strong>就用相对应的异常类进行捕捉。并且打印出相应的异常信息。</strong>catch <strong>块，必须要配合</strong> try <strong>块一起使用，不能单独使用，也不能直接和</strong> finally **块一起使用。<br><strong>catch</strong> 关键字用来在 <strong>try-catch</strong> 或 <strong>try-catch-finally</strong> 语句中定义异常处理块。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	&lt;可能引发异常的块&gt;<br>&#125; <span class="hljs-keyword">catch</span> (&lt;java.lang.Exception 或子类&gt; e) &#123;<br>		&lt;处理异常 e 的代码&gt;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>	&lt;可能引发其他异常的块&gt;<br>&#125; <span class="hljs-keyword">catch</span> (FooException e) &#123;<br>	&lt;处理 FooException e 的代码&gt;<br>&#125; <span class="hljs-keyword">catch</span> (BarException e) &#123;<br>	&lt;处理 BarException e 的代码&gt;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>	&lt;可能引发异常的块&gt;<br>&#125; <span class="hljs-keyword">catch</span> (&lt;java.lang.Exception 或子类&gt; e) &#123;<br>	&lt;处理异常 e 的代码&gt;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>	&lt;有异常或无异常情况下都执行的语句&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>开始和结束标记 ** {** 和 <strong>}</strong> 是 <strong>catch</strong> 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。<br>每个 <strong>try</strong> 块都必须至少有一个 <strong>catch</strong> 或 <strong>finally</strong> 子句。<br>如果某个特定异常类未被任何 <strong>catch</strong> 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 <strong>try</strong> 块。如果任何封闭 <strong>try</strong> 块都未捕获到异常，Java &gt;解释器将退出，并显示错误消息和堆栈跟踪信息。</p>
</blockquote>
<h2 id="7-char"><a href="#7-char" class="headerlink" title="7.char"></a>7.char</h2><blockquote>
<p>用法：char 是 Java 原始类型。<br><strong>char</strong> 变量可以存储一个** Unicode** 字符。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">delimiter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;;&#x27;</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>可以使用下列 <strong>char</strong> 常量：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">\b - 空格<br>\f - 换页<br>\n - 换行<br>\r - 回车<br>\t - 水平制表符<br>\<span class="hljs-string">&#x27; - 单引号</span><br><span class="hljs-string">\&quot; - 双引号</span><br><span class="hljs-string">\&quot; - 反斜杠</span><br><span class="hljs-string">\xxx - 采用 xxx 编码的 Latin-1 字符。\x 和 \xx 均为合法形式，但可能引起混淆。</span><br><span class="hljs-string">\uxxxx - 采用十六进制编码 xxxx 的 Unicode 字符。</span><br></code></pre></td></tr></table></figure>
<p><strong>Character</strong> 类包含一些可用来处理** char <strong>变量的</strong> static **方法，这些方法包括 <strong>isDigit()<strong>、</strong>isLetter()<strong>、</strong>isWhitespace()</strong> 和 **toUpperCase()**。<br>**char **值没有符号。</p>
<h2 id="8-class"><a href="#8-class" class="headerlink" title="8.class"></a>8.class</h2><blockquote>
<p>解释：类，种类<br>用法：定义一个类，这时候定义的类，在内存空间里面没有分配空间。换句话说，它还没有存在于现实生活中，它不是一个实体。类里面有方法有属性，要想访问它里面的方法和属性就要通过对象去使用。<br>格式如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">访问权限修饰符 class 类名&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>class 关键字用来声明新的 Java 类，该类是相关变量和&#x2F;或方法的集合。<br>类是面向对象的程序设计方法的基本构造单位。类通常代表某种实际实体，如几何形状或人。类是对象的模板。每个对象都是类的一个实例。<br>要使用类，通常使用 <strong>new</strong> 操作符将类的对象实例化，然后调用类的方法来访问类的功能。</p>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>&#123;<br>	<span class="hljs-type">float</span> width;<br>	<span class="hljs-type">float</span> height;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(<span class="hljs-type">float</span> w, <span class="hljs-type">float</span> h)</span>&#123;<br>		width = w;<br>		height = h;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getWidth</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> width;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> height;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="9-continue"><a href="#9-continue" class="headerlink" title="9.continue"></a>9.continue</h2><blockquote>
<p>用法：<strong>continue</strong> 关键字用来跳转到 <strong>for</strong>、<strong>while</strong> 或 <strong>do</strong> 循环的下一个迭代。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;max; i++)&#123;<br>	&lt;statements&gt;<br>	<span class="hljs-keyword">if</span> (&lt;done with <span class="hljs-built_in">this</span> iteration&gt;)&#123;<br>		<span class="hljs-keyword">continue</span>;<br>	&#125;<br>	&lt;statements&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>continue</strong> 总是跳到最深层 <strong>while</strong>、<strong>for</strong> 或 <strong>do</strong> 语句的下一个迭代。</p>
</blockquote>
<h2 id="10-default"><a href="#10-default" class="headerlink" title="10.default"></a>10.default</h2><blockquote>
<p>用法：<strong>default</strong> 关键字用来标记 **switch **语句中的默认分支。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> &lt;some value&gt;;<br><span class="hljs-keyword">switch</span> (arg)&#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">default</span>:<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>default</strong> 块没有隐式结束点。<strong>break</strong> 语句通常在每个 <strong>case</strong> 或 <strong>default</strong> 块的末尾使用，以便在完成块时退出 **switch <strong>语句。<br>如果没有 <strong>default</strong> 语句，其参数与任何 <strong>case</strong> 块都不匹配的 switch</strong> 语句将不执行任何操作。</p>
</blockquote>
<h2 id="11-do"><a href="#11-do" class="headerlink" title="11.do"></a>11.do</h2><blockquote>
<p>用法：<strong>do</strong> 关键字用于指定一个在每次迭代结束时检查其条件的循环。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>	&lt;statements&gt;<br>&#125;<br><span class="hljs-keyword">while</span> (!found);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>do</strong> 循环体至少执行一次。<br>条件表达式后面必须有分号。</p>
</blockquote>
<h2 id="12-double"><a href="#12-double" class="headerlink" title="12.double"></a>12.double</h2><blockquote>
<p>用法：<strong>double</strong> 是 Java 原始类型。<strong>double</strong> 变量可以存储双精度浮点值。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">ratio</span> <span class="hljs-operator">=</span> <span class="hljs-number">.01</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">diameter</span> <span class="hljs-operator">=</span> <span class="hljs-number">6.15</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.35E03</span>;   <span class="hljs-comment">// 1.35 * 103 或 1350.0</span><br><span class="hljs-type">double</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">1e-2</span>;   <span class="hljs-comment">// 1.0 * 10-2 或 0.01</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。<br>Java 浮点数值可代表无穷大和 NaN（非数值）。<strong>Double</strong> 包装对象类用来定义常量 <strong>MIN_VALUE</strong>、<strong>MAX_VALUE</strong>、<strong>NEGATIVE_INFINITY</strong>、<strong>POSITIVE_INFINITY</strong> 和 <strong>NaN</strong>。</p>
</blockquote>
<h2 id="13-else"><a href="#13-else" class="headerlink" title="13.else"></a>13.else</h2><blockquote>
<p>用法：<strong>else</strong> 关键字总是在 <strong>if-else</strong> 语句中与 <strong>if</strong> 关键字结合使用。<strong>else</strong> 子句是可选的，如果 <strong>if</strong> 条件为 <strong>false</strong>，则执行该子句。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (condition)&#123;<br>	&lt;statements&gt;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>	&lt;statements&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="14-extends"><a href="#14-extends" class="headerlink" title="14.extends"></a>14.extends</h2><blockquote>
<p>解释：扩充，扩展<br>用法：一个类继承另一个类的关键字，当出现了这个关键字，两个类就有了继承关系，**extends <strong>前面的类，我们称之为父类。</strong>extends **后面的类，我们称之为子类。有了继承关系之后，我们就说子类拥有父类继承下来的所有非私有的成员（包括了属性，方法），但是不包括构造方法<br><strong>extends</strong> 关键字用在 <strong>class</strong> 或 <strong>interface</strong> 声明中，用于指示所声明的类或接口是其名称后跟有 <strong>extends</strong> 关键字的类或接口的子类。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Polygon</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>在上例中，Rectangle 类继承 <strong>Polygon</strong> 类的所有 <strong>public</strong> 和 <strong>protected</strong> 变量和方法。<br><strong>Rectangle</strong> 类可以重写 <strong>Polygon</strong> 类的任何非 <strong>final</strong> 方法。<br>一个类只能扩展一个其他类。</p>
</blockquote>
<h2 id="15-false"><a href="#15-false" class="headerlink" title="15.false"></a>15.false</h2><blockquote>
<p>解释：假，布尔型的字面值<br>用法：**boolean **类型的取值范围之一。<br>false 关键字代表 <strong>boolean</strong> 变量的两个合法值之一。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">isComplete</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<h2 id="16-final"><a href="#16-final" class="headerlink" title="16.final"></a>16.final</h2><blockquote>
<p>解释：最终的，决定性的<br>用法：修饰符的一种，它可以用来修饰类，方法，属性。当一个属性被修饰成** final <strong>的之后，这个属性变成了常量，它的值必须在定义的时候初始化，并且后面的代码不能对其进行修改，它的命名应该全部都是大写。当一个方法被修饰成</strong> final **的之后，这个方法在继承中是不能够被进行覆盖的。当一个类被修饰成 final 的之后，这个类不能再有子类。<br><strong>final</strong> 关键字可以应用于类，以指示不能扩展该类（不能有子类）。<br><strong>final</strong> 关键字可以应用于方法，以指示不能重写任何子类中的方法。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFinalClass</span>&#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">myFinalMethod</span><span class="hljs-params">()</span><br>	&#123;<br>		&lt;statements&gt;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Math</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>		<span class="hljs-keyword">return</span> i&gt;=<span class="hljs-number">0</span>?i:-I;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>一个类不能同时是 abstract 又是 <strong>final</strong>。<strong>abstract</strong> 意味着必须扩展类，<strong>final</strong> 意味着不能扩展类。<br>一个方法不能同时是 abstract 又是** final<strong>。</strong>abstract** 意味着必须重写方法，<strong>final</strong> 意味着不能重写方法。</p>
</blockquote>
<ol>
<li>对于基本类型前加以** final <strong>修饰，表示被修饰的变量为常数，不可以修改。一个既是</strong> static <strong>又是</strong> final **的字段表示只占据一段不能改变的存储空间。</li>
<li>**final <strong>用于对象应用时，</strong>final **使应用恒定不变。一旦引用被初始化指向一个对象，就无法再把它指向另一个对象。</li>
<li><strong>final <strong>方法：一是把方法锁定，以防止继承类修改它的含义，二是确保继承中使方法行为保持不变，并且不会被覆盖。类中所有的</strong> private <strong>方法都隐式地指定为是</strong> final</strong>。</li>
<li>**final **参数：对于基本类型的变量，这样做并没有什么实际意义，因为基本类型的变量在调用方法时是传值，也就是说你可以在方法中更改这个参数变量而不会影响到调用语句，然而对于对象变量，却显得很实用，以为对象变量在传递时是传递其引用，这样你在方法中对对象变量的修改也会影响到调用语句的对象变量，当你在方法中不需要改变作为参数的变量时，明确使用 final 进行声明，会防止你无意的修改而影响到调用方法。</li>
<li>final 类：当将某个类的整体定义为 final 时，就表明了该类不允许被继承。</li>
</ol>
<h2 id="17-finally"><a href="#17-finally" class="headerlink" title="17.finally"></a>17.finally</h2><blockquote>
<p>解释：最后，终于，不可更改地<br>用法：在异常处理机制当中，它的作用就像是人吃饭一样，必须得做的，不论有异常还是没有异常都要执行的代码就可以放到** finally <strong>块当中去。</strong>finally <strong>块，必须要配合</strong> try <strong>块一起使用，不能单独使用，也不能直接和</strong> catch **块一起使用。<br><strong>finally</strong> 关键字用来定义始终在 <strong>try-catch-finally</strong> 语句中执行的块。<br><strong>finally</strong> 块通常包含清理代码，用在部分执行 <strong>try</strong> 块后恢复正常运行。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>	&lt;可能引发异常的块&gt;<br>&#125;<br><span class="hljs-keyword">catch</span> (&lt;java.lang.Exception 或子类&gt; e)&#123;<br>	&lt;处理异常 e 的代码&gt;<br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br>	&lt;有异常或无异常情况下都执行的语句&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>开始和结束标记 <strong>{</strong> 和 <strong>}</strong> 是 <strong>finally</strong> 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。<br>每个 <strong>try</strong> 块都必须至少有一个 <strong>catch</strong> 或 <strong>finally</strong> 子句。<br>如果执行 <strong>try</strong> 块的任何部分，不论是否出现异常，也不论 <strong>try</strong> 或 <strong>catch</strong> 块是否包含 <strong>return</strong>、<strong>continue</strong> 或 <strong>break</strong> 语句，都一定会执行 <strong>finally</strong> 块中的代码。<br>如果不出现异常，控件将跳过 <strong>try</strong> 块，进入 <strong>finally</strong> 块。<br>如果在执行 <strong>try</strong> 块期间出现异常，并且相应的 catch 块包含 <strong>break</strong>、<strong>continue</strong> 或 <strong>return</strong> 语句，控件将首先穿过 <strong>finally</strong> 块，之后再执行 <strong>break</strong>、<strong>continue</strong> 或 <strong>return</strong>。</p>
</blockquote>
<h2 id="18-float"><a href="#18-float" class="headerlink" title="18.float"></a>18.float</h2><blockquote>
<p>用法：<strong>float</strong> 是 Java 原始类型。<strong>float</strong> 变量可以存储单精度浮点值。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">ratio</span> <span class="hljs-operator">=</span> <span class="hljs-number">.01</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">diameter</span> <span class="hljs-operator">=</span> <span class="hljs-number">6.15</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.35E03</span>;   <span class="hljs-comment">// 1.35 * 103 或 1350.0</span><br><span class="hljs-type">float</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">1e-2</span>;   <span class="hljs-comment">// 1.0 * 10-2 或 0.01</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>使用此关键字时应遵循下列规则：<br>Java 中的浮点文字始终默认为双精度。要指定单精度文字值，应在数值后加上 <strong>f</strong> 或 <strong>F</strong>，如 <strong>0.01f</strong>。<br>由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。<br>Java 浮点数值可代表无穷大和 NaN（非数值）。<strong>Float</strong> 包装对象类用来定义常量** MIN_VALUE<strong>、</strong>MAX_VALUE<strong>、</strong>NEGATIVE_INFINITY<strong>、</strong>POSITIVE_INFINITY** 和 <strong>NaN</strong>。</p>
</blockquote>
<h2 id="19-for"><a href="#19-for" class="headerlink" title="19.for"></a>19.for</h2><blockquote>
<p>用法：<strong>for</strong> 关键字用于指定一个在每次迭代结束前检查其条件的循环。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;max; i++)&#123;<br>&lt;statements&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>for</strong> 语句的形式为 <strong>for(initialize; condition; increment)</strong><br>控件流进入 <strong>for</strong> 语句时，将执行一次 <strong>initialize</strong> 语句。<br>每次执行循环体之前将计算 <strong>condition</strong> 的结果。如果 <strong>condition</strong> 为 <strong>true</strong>，则执行循环体。<br>每次执行循环体之后，在计算下一个迭代的 <strong>condition</strong> 之前，将执行 <strong>increment</strong> 语句。</p>
</blockquote>
<h2 id="20-if"><a href="#20-if" class="headerlink" title="20.if"></a>20.if</h2><blockquote>
<p>用法：if 关键字指示有条件地执行代码块。条件的计算结果必须是布尔值。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (condition)&#123;<br>	&lt;statements&gt;<br>&#125;<br><span class="hljs-keyword">if</span> (condition)&#123;<br>	&lt;statements&gt;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>	&lt;statements&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>if</strong> 语句可以有可选的 <strong>else</strong> 子句，该子句包含条件为 <strong>false</strong> 时将执行的代码。<br>包含 <strong>boolean</strong> 操作数的表达式只能包含 <strong>boolean</strong> 操作数。</p>
</blockquote>
<h2 id="21-implements"><a href="#21-implements" class="headerlink" title="21.implements"></a>21.implements</h2><blockquote>
<p>解释：实现<br>用法：用来让一个类实现一个接口的关键字，实现接口的这个类必须实现接口里面所有的方法。<br><strong>implements</strong> 关键字在 <strong>class</strong> 声明中使用，以指示所声明的类提供了在 **implements *关键字后面的名称所指定的接口中所声明的所有方法的实现。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Truck</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVehicle</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>在上例中，<strong>Truck</strong> 类必须提供在 <strong>IVehicle</strong> 接口中所声明的所有方法的实现。<br>否则，<strong>Truck</strong> 类将是独立的；它可以声明其他方法和变量，并扩展另一个类。<br>一个类可以实现多个接口。</p>
</blockquote>
<h2 id="22-import"><a href="#22-import" class="headerlink" title="22.import"></a>22.import</h2><blockquote>
<p>解释：引入，导入<br>用法：相对应打包而言，当一个类被放在包下面了，如果要使用这个类就必须到这个包下面去寻找这个类，因此出现了导包语句。导包可以有多条语句。<br><strong>import</strong> 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.net.*;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>-注释-<br>当多个包包含同名的类时，许多 Java 程序员只使用特定的 <strong>import</strong> 语句（没有“*”）来避免不确定性。</p>
</blockquote>
<h2 id="23-instanceof"><a href="#23-instanceof" class="headerlink" title="23.instanceof"></a>23.instanceof</h2><blockquote>
<p>用法：instanceof 关键字用来确定对象所属的类。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)&#123;<br>	&lt;statements&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>在上例中，如果 <strong>node</strong> 是 <strong>TreeNode</strong> 类的实例，或者是 <strong>TreeNode</strong> 的子类的实例，则 <strong>instanceof</strong> 表达式的值将为 <strong>true</strong>。<br>**instanceof **通常是用于判断父类或者接口的引用是否是某个子类的实例，例如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br>Animal a= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>System.out.println( a <span class="hljs-keyword">instanceof</span> Bird);<br>System.out.println( a <span class="hljs-keyword">instanceof</span> Dog);<br></code></pre></td></tr></table></figure>

<h2 id="24-int"><a href="#24-int" class="headerlink" title="24.int"></a>24.int</h2><blockquote>
<p>用法：<strong>int</strong> 是 Java 原始类型。<br><strong>int</strong> 变量可以存储 32 位的整数值。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">octalNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0377</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">hexNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xff</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>Integer</strong> 类是 <strong>int</strong> 原始类型的包装对象类。它定义代表此类型的值的范围的 <strong>MIN_VALUE</strong> 和 <strong>MAX_VALUE</strong> 常量。<br>Java 中的所有整数值都是 32 位的 <strong>int</strong> 值，除非值后面有 <strong>l</strong> 或 <strong>L</strong>（如 235L），这表示该值应解释为 <strong>long</strong>。</p>
</blockquote>
<h2 id="25-interface"><a href="#25-interface" class="headerlink" title="25.interface"></a>25.interface</h2><blockquote>
<p>解释：接口，界面<br>用法：它本质上是一个类，一个完全抽象的类，里面没有任何实现的方法。它不是用来继承的，是用来实现的。某个类如果实现了接口就必须要实现接口里面的所有方法。并且接口是不能用来实例化的，它也是不能通过** new **关键字获得对象。<br><strong>interface</strong> 关键字用来声明新的 Java 接口，接口是方法的集合。<br>接口是 Java 语言的一项强大功能。任何类都可声明它实现一个或多个接口，这意味着它实现了在这些接口中所定义的所有方法。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPolygon</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumberOfSides</span><span class="hljs-params">()</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCircumference</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>实现了接口的任何类都必须提供在该接口中的所有方法的实现。<br>一个类可以实现多个接口。</p>
</blockquote>
<h2 id="26-long"><a href="#26-long" class="headerlink" title="26.long"></a>26.long</h2><p>用法：<strong>long</strong> 是 Java 原始类型。**long **变量可以存储 64 位的带符号整数。</p>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">anotherNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">34590L</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">octalNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0377</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">hexNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xffl</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>Long</strong> 类是 <strong>long</strong> 原始类型的包装对象类。它定义代表此类型的值的范围的 <strong>MIN_VALUE</strong> 和 <strong>MAX_VALUE</strong> 常量。<br>Java 中的所有整数值都是 32 位的 <strong>int</strong> 值，除非值后面有 <strong>l</strong> 或 <strong>L</strong>（如 235L），这表示该值应解释为** long**。</p>
</blockquote>
<h2 id="27-native"><a href="#27-native" class="headerlink" title="27.native"></a>27.native</h2><blockquote>
<p>说明：<strong>native</strong> 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">native</span> String <span class="hljs-title function_">getProcessorType</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>Java 不是完美的，Java 的不足除了体现在运行速度上要比传统的 C++慢许多之外，Java 无法直接访问到操作系统底层（如系统硬件等），为此 Java 使用** native <strong>方法来扩展 Java 程序的功能。<br>可以将 native 方法比作 Java 程序同Ｃ程序的接口，其实现步骤：<br>１. 在 Java 中声明</strong> native() <strong>方法，然后编译；<br>２. 用 javah 产生一个</strong>.h <strong>文件；<br>３. 写一个。cpp 文件实现 native 导出方法，其中需要包含第二步产生的</strong>.h <strong>文件（注意其中又包含了 JDK 带的</strong> jni.h <strong>文件）；<br>４. 将第三步的。cpp 文件编译成动态链接库文件；<br>５. 在 Java 中用</strong> System.loadLibrary() <strong>方法加载第四步产生的动态链接库文件，这个</strong> native() **方法就可以在 Java 中被访问了。</p>
</blockquote>
<blockquote>
<p>JAVA 本地方法适用的情况</p>
</blockquote>
<ol>
<li>为了使用底层的主机平台的某个特性，而这个特性不能通过 JAVA API 访问</li>
<li>为了访问一个老的系统或者使用一个已有的库，而这个系统或这个库不是用 JAVA 编写的</li>
<li>为了加快程序的性能，而将一段时间敏感的代码作为本地方法实现。<br>首先写好 JAVA 文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Created on 2005-12-19 Author shaoqi</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">package</span> com.hode.hodeframework.modelupdate;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckFile</span><br>&#123;<br>　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayHelloWorld</span><span class="hljs-params">()</span>;<br>　　<span class="hljs-keyword">static</span><br>　　&#123;<br>　　	System.loadLibrary(<span class="hljs-string">&quot;test&quot;</span>);<br>　　&#125;<br>　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>　　	<span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckFile</span>().displayHelloWorld();<br>　　&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
然后根据写好的文件编译成** CLASS <strong>文件<br>然后在 classes 或 bin 之类的</strong> class <strong>根目录下执行</strong> javah -jni com.hode.hodeframework.modelupdate.CheckFile<strong>， 就会在根目录下得到一个</strong> com_hode_hodeframework_modelupdate_CheckFile.h <strong>的文件，然后根据头文件的内容编写</strong> com_hode_hodeframework_modelupdate_CheckFile.c **文件<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CheckFile.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span></span><br>JNIEXPORT <span class="hljs-type">void</span> JNICALL <span class="hljs-title function_">Java_com_hode_hodeframework_modelupdate_CheckFile_displayHelloWorld</span><span class="hljs-params">(JNIEnv *env, jobject obj)</span><br>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world!\n&quot;</span>);<br>　　<span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
之后编译生成 DLL 文件如“test.dll”，名称与** System.loadLibrary(“test”) <strong>中的名称一致<br>vc 的编译方法：<code>cl -I%java_home%\include -I%java_home%\include\win32 -LD com_hode_hodeframework_modelupdate_CheckFile.c -Fetest.dll</code><br>最后在运行时加参数</strong>-Djava.library.path&#x3D;[dll 存放的路径]**</li>
</ol>
<h2 id="28-new"><a href="#28-new" class="headerlink" title="28.new"></a>28.new</h2><blockquote>
<p>解释：新建<br>用法：创建对象时使用，当一看倒** new **关键字，意味着在内存的堆空间里开辟了一个空间，存放了相对应类型的对象出来。创建的对象由一个相对应类型的引用去指向访问，类似与 C 语言中指针的用法。<br>格式如下：<code>类名 引用名 = new 类名 ()</code>。<br><strong>new</strong> 关键字用于创建类的新实例。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sName</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><span class="hljs-type">Float</span> <span class="hljs-variable">fVal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>(<span class="hljs-number">0.15</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>new</strong> 关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数（必须带括号）。<br>参数集合必须与类的构造方法的签名匹配。<br>&#x3D; 左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系。</p>
</blockquote>
<h2 id="29-null"><a href="#29-null" class="headerlink" title="29.null"></a>29.null</h2><blockquote>
<p>解释：空<br>用法：对象的一种取值，称呼为：“null 值”，这时候我们理解成内存里面还没有得到这个对象空间。<br><strong>null</strong> 是 Java 的保留字，表示无值。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i;<br>i = <span class="hljs-literal">null</span>;<br>String s;<br><span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)&#123;<br>	&lt;statements&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>将 <strong>null</strong> 赋给非原始变量相当于释放该变量先前所引用的对象。<br>不能将 <strong>null</strong> 赋给原始类型（<strong>byte、short、int、long、char、float、double、boolean</strong>）变量。</p>
</blockquote>
<h2 id="30-package"><a href="#30-package" class="headerlink" title="30.package"></a>30.package</h2><blockquote>
<p>解释：包裹，包<br>用法：为了防止同一个目录下面存在于两个相同名字的源文件，使用打包的用处和文件夹的作用是相似的。要注意，打包语句一定只能放在源文件的第一句话，并且不能在同一个源文件中出现两个或者两个以上的打包语句。包可以嵌套，通常来讲，第一个包称之为根包，后面的嵌套包称之为子包。<br><strong>package</strong> 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mycompany;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>package</strong> 语句（如果出现）必须是 Java 源文件中的第一个非-注释-性文本。<br>在上面的**-示例-<strong>中，</strong>MyClass** 类的完全限定类名是 <strong>com.mycompany.MyClass</strong>。<br>如果 Java 源文件不包含 <strong>package</strong> 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。</p>
</blockquote>
<h2 id="31-private"><a href="#31-private" class="headerlink" title="31.private"></a>31.private</h2><blockquote>
<p>解释：访问权限修饰符的一种，私有的意思。<br>用法：用来修饰属性，方法。只能类的内部本身才能够访问，不能修饰类。<br><strong>private</strong> 关键字是访问控制修饰符，可以应用于方法或字段（在类中声明的变量）。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPublicClass</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrivateClass</span>&#123;<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> i;<br>	<span class="hljs-keyword">private</span> String <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>&#123;<br>		&lt;statements&gt;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>只能在声明 <strong>private</strong>（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。<br>所有类成员的默认访问范围都是 <strong>package</strong> 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。</p>
</blockquote>
<h2 id="32-protected"><a href="#32-protected" class="headerlink" title="32.protected"></a>32.protected</h2><blockquote>
<p>解释：访问权限修饰符的一种，受保护的意思。<br>用法：用来修饰属性，方法。只能符合有包内友好关系，或者是父子友好的类才能够访问，不能修饰类。<br><strong>protected</strong> 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPublicClass</span>&#123;<br>	<span class="hljs-keyword">protected</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrivateClass</span>&#123;<br>	&#125;<br>	<span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> i;<br>	<span class="hljs-keyword">protected</span> String <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>&#123;<br>		&lt;statements&gt;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>可以在声明 <strong>protected</strong> 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。<br>所有类成员的默认访问范围都是 <strong>package</strong> 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。</p>
</blockquote>
<h2 id="33-public"><a href="#33-public" class="headerlink" title="33.public"></a>33.public</h2><blockquote>
<p>解释：访问权限修饰符的一种，公开，公共的意思。<br>用法：用来修饰类，属性，方法。对于外部的任何类都能够访问。<br><strong>public</strong> 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPublicClass</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrivateClass</span>&#123;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> i;<br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>&#123;<br>		&lt;statements&gt;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>可能只会在其他任何类或包中引用 <strong>public</strong> 类、方法或字段。<br>所有类成员的默认访问范围都是 <strong>package</strong> 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。</p>
</blockquote>
<h2 id="34-return"><a href="#34-return" class="headerlink" title="34.return"></a>34.return</h2><blockquote>
<p>用法：<strong>return</strong> 关键字会导致方法返回到调用它的方法，从而传递与返回方法的返回类型匹配的值。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myVoidMethod</span><span class="hljs-params">()</span>&#123;<br>	&lt;statements&gt;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">myStringMethod</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;my response&quot;</span>;<br>	<span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myIntMethod</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>	<span class="hljs-keyword">return</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>如果方法具有非 <strong>void</strong> 的返回类型，<strong>return</strong> 语句必须具有相同或兼容类型的参数。<br>返回值两侧的括号是可选的。</p>
</blockquote>
<h2 id="35-short"><a href="#35-short" class="headerlink" title="35.short"></a>35.short</h2><blockquote>
<p>用法：<strong>short</strong> 是 Java 原始类型。<strong>short</strong> 变量可以存储 16 位带符号的整数。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">short</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">octalNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0077</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">hexNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xff</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>Short</strong> 类是 <strong>short</strong> 原始类型的包装对象类。它定义代表此类型的值的范围的 <strong>MIN_VALUE</strong> 和 <strong>MAX_VALUE</strong> 常量。<br>Java 中的所有整数值都是 32 位的 <strong>int</strong> 值，除非值后面有 <strong>l</strong> 或 <strong>L</strong>（如 235L），这表示该值应解释为 <strong>long</strong>。</p>
</blockquote>
<h2 id="36-static"><a href="#36-static" class="headerlink" title="36.static"></a>36.static</h2><blockquote>
<p>解释：静态的<br>用法：修饰符的一种，能够用来修饰属性和方法。需要注意的是被修饰的属性和方法，不再属于对象所有，而是属于类，意味着，要访问这些属性和方法不再通过对象而是直接用类名来访问。另外，静态的方法不能够访问非静态属性，非静态的方法能够访问静态的属性。<br><strong>static</strong> 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPublicClass</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_OBJECTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>	<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_numObjects</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStaticClass</span>&#123;<br>	&#125;<br>	<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumObjects</span><span class="hljs-params">()</span>&#123;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>通常，<strong>static</strong> 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。<br><strong>static</strong>（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的**-示例-**中，另一个类中的代码可以实例化 <strong>MyStaticClass <strong>类，方法是用包含它的类名来限定其名称，如 <strong>MyClass.MyStaticClass</strong>。<br>static 字段（类的成员变量）在类的所有实例中只存在一次。<br>可以从类的外部调用 <strong>static</strong> 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。在上面的示例中，</strong>MyClass</strong> 类外部的代码以 <strong>MyClass.getNumObjects()</strong> 的形式调用 <strong>getNumObjects() static</strong> 方法。</p>
</blockquote>
<p><strong>模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> &lt;type&gt; varName = &lt;value&gt;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的**-示例-**中，另一个类可以用 <strong>MyClass.MAX_OBJECTS</strong> 形式来引用 <strong>MAX_OBJECTS</strong> 常量。</p>
</blockquote>
<ol>
<li>通常在一个类中定义一个方法为** static**，就是说无须本类的对象就可以直接调用。</li>
<li>静态变量和静态方法类似。所有此类实例共享此静态变量，也就是说类装载时，只分配一块存储空间，所有此类的对象都可以操控此块存储空间，当然对于 final 就另当别论了。</li>
<li>static 定义的变量会优先于任何其他非** static **变量，不论其出现顺序如何。</li>
<li>**static{}<strong>着是用来显式的静态变量初始化，这段代码只会初始化一次，且在类被第一次装载时。<br>5&gt;在涉及到继承的时候，会先初始化父类的</strong> static **变量，然后是子类的。<br>6&gt;通常一个普通类不允许声明为静态的，只有一个内部类才可以。这时这个声明为静态的内部类可以直接作为一个普通类来使用，而不需要实例一个外部类。</li>
</ol>
<h2 id="37-super"><a href="#37-super" class="headerlink" title="37.super"></a>37.super</h2><blockquote>
<p>解释：上一级的，超级的<br>用法：代表了当前类中父类的对象。能够去调用父类的构造方法，属性，方法。但是需要注意，如果是在当前类的构造方法中去调用父类的构造方法，必须把调用语句写在本类构造方法的第一句上。<br><strong>super</strong> 关键字用于引用使用该关键字的类的超类。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">(String arg)</span>&#123;<br>		<span class="hljs-built_in">super</span>(arg);<br>	&#125;<br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">myStringMethod</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.otherStringMethod();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>作为独立语句出现的 <strong>super</strong> 表示调用超类的构造方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.&lt;methodName&gt;()<br></code></pre></td></tr></table></figure>
<blockquote>
<p>表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。</p>
</blockquote>
<ol>
<li>在你的方法中的某个刑参名与当前对象的某个成员有相同的名字，这时为了不至于混淆，你便要明确使用** this <strong>关键字来指明你要使用某个成员，使用方法是</strong> this. 成员名<strong>，而不带</strong> this <strong>的那个便是</strong>形参<strong>。另外，还可以用</strong> this. 方法名<strong>来引用当前对象的某个方法，但这时</strong> this **就不是必须的了，你可以直接用方法名来访问那个方法。</li>
<li>当父类的方法被重写后可以用** super <strong>来调用父类的方法。如果父类的方法可以被子类调用，那你可以象使用</strong> this <strong>一样使用它，用</strong> super. 父类中的成员名**的方式来调用。</li>
<li>**super <strong>和</strong> this <strong>直接在其后跟上适当的参数，因此它的意义就有了变化。</strong>super <strong>后加参数的是用来调用父类中具有相同形式的构造函数，</strong>this **后加参数则调用的是当前具有相同参数的构造函数。</li>
<li>**this <strong>通常指代当前对象，</strong>super **通常指带父类。</li>
</ol>
<h2 id="38-switch"><a href="#38-switch" class="headerlink" title="38.switch"></a>38.switch</h2><blockquote>
<p>用法：switch 语句用于基于某个表达式选择执行多个代码块中的某一个。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> &lt;some value&gt;;<br><span class="hljs-keyword">switch</span> (arg)&#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">default</span>:<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-type">char</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> &lt;some value&gt;;<br><span class="hljs-keyword">switch</span> (arg)&#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;y&#x27;</span>:<br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Y&#x27;</span>:<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:<br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;N&#x27;</span>:<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">default</span>:<br>		&lt;statements&gt;<br>	<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>switch</strong> 条件的计算结果必须等于 <strong>byte</strong>、<strong>char</strong>、<strong>short</strong> 或 <strong>int</strong>。<br><strong>case</strong> 块没有隐式结束点。<strong>break</strong> 语句通常在每个 <strong>case</strong> 块末尾使用，用于退出 <strong>switch</strong> 语句。<br>如果没有 <strong>break</strong> 语句，执行流将进入所有后面的 <strong>case</strong> 和**<code>/</code>**或 <strong>default</strong> 块。</p>
</blockquote>
<h2 id="39-synchronized"><a href="#39-synchronized" class="headerlink" title="39.synchronized"></a>39.synchronized</h2><p>用法：<strong>synchronized</strong> 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码</p>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">mySyncStaticMethod</span><span class="hljs-params">()</span>&#123;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">mySyncMethod</span><span class="hljs-params">()</span>&#123;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyOtherClass</span>&#123;<br>	Object someObj;<br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>&#123;<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">synchronized</span> (someObj)&#123;<br>			&lt;statements affecting someObj&gt;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>synchronized</strong> 关键字可防止代码的关键代码段一次被多个线程执行。<br>如果应用于静态方法（如上例中的 <strong>MySyncStaticMethod</strong>），那么，当该方法一次由一个线程执行时，整个类将被锁定。<br>如果应用于实例方法（如上例中的 <strong>MySyncMethod</strong>），那么，当该方法一次由一个线程访问时，该实例将被锁定。<br>如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。<br><strong>synchronized</strong> 关键字，它包括两种用法：<strong>synchronized</strong> 方法和 <strong>synchronized</strong> 块。</p>
</blockquote>
<ol>
<li>synchronized 方法：通过在方法声明中加入 **synchronized **关键字来声明 **synchronized **方法。<br>如： 　<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accessVal</span><span class="hljs-params">(<span class="hljs-type">int</span> newVal)</span>;<br></code></pre></td></tr></table></figure>
<strong>synchronized</strong> 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 <strong>synchronized</strong> 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 <strong>synchronized</strong> 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 <strong>synchronized</strong>）。<br>　在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 <strong>synchronized</strong>，以控制其对类的静态成员变量的访问。<br><strong>synchronized</strong> 方法的缺陷：若将一个大的方法声明为** synchronized** 将会大大影响效率，典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 <strong>synchronized</strong> 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 <strong>synchronized</strong> ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 <strong>synchronized</strong> 块。</li>
<li><strong>synchronized</strong> 块：通过 <strong>synchronized <strong>关键字来声明</strong> synchronized</strong> 块。语法如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(syncObject) &#123;<br>　　<span class="hljs-comment">//允许访问控制的代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<strong>synchronized <strong>块是这样一个代码块，其中的代码必须获得对象</strong> syncObject</strong> （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。<br>对** synchronized(this) <strong>的一些理解<br>一、当两个并发线程访问同一个对象</strong> object <strong>中的这个</strong> synchronized(this) <strong>同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</strong>package ths;**<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; synchronized loop &quot;</span> + i);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">Thread1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread1</span>();<br>		<span class="hljs-type">Thread</span> <span class="hljs-variable">ta</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t1, <span class="hljs-string">&quot;A&quot;</span>);<br>		<span class="hljs-type">Thread</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t1, <span class="hljs-string">&quot;B&quot;</span>);<br>		ta.start();<br>		tb.start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<strong>结果：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">A <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">0</span><br>A <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">1</span><br>A <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">2</span><br>A <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">3</span><br>A <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">4</span><br>B <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">0</span><br>B <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">1</span><br>B <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">2</span><br>B <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">3</span><br>B <span class="hljs-keyword">synchronized</span> loop <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
二、然而，当一个线程访问 object 的一个** synchronized(this) <strong>同步代码块时，另一个线程仍然可以访问该</strong> object <strong>中的非</strong> synchronized(this) **同步代码块。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ths;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread2</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4t1</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>			<span class="hljs-keyword">while</span>( i-- &gt; <span class="hljs-number">0</span>) &#123;<br>				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br>				<span class="hljs-keyword">try</span> &#123;<br>					Thread.sleep(<span class="hljs-number">500</span>);<br>				&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4t2</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>		<span class="hljs-keyword">while</span>( i-- &gt; <span class="hljs-number">0</span>) &#123;<br>			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br>			<span class="hljs-keyword">try</span> &#123;<br>				Thread.sleep(<span class="hljs-number">500</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-keyword">final</span> <span class="hljs-type">Thread2</span> <span class="hljs-variable">myt2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread2</span>();<br>		<span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  myt2.m4t1();  &#125;  &#125;, <span class="hljs-string">&quot;t1&quot;</span>  );<br>		<span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; myt2.m4t2();   &#125;  &#125;, <span class="hljs-string">&quot;t2&quot;</span>  );<br>		t1.start();<br>		t2.start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<strong>结果：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">t1 : <span class="hljs-number">4</span><br>t2 : <span class="hljs-number">4</span><br>t1 : <span class="hljs-number">3</span><br>t2 : <span class="hljs-number">3</span><br>t1 : <span class="hljs-number">2</span><br>t2 : <span class="hljs-number">2</span><br>t1 : <span class="hljs-number">1</span><br>t2 : <span class="hljs-number">1</span><br>t1 : <span class="hljs-number">0</span><br>t2 : <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
三、尤其关键的是，当一个线程访问** object <strong>的一个</strong> synchronized(this) <strong>同步代码块时，其他线程对</strong> object <strong>中所有其它</strong> synchronized(this) **同步代码块的访问将被阻塞。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改 Thread2.m4t2() 方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4t2</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>		<span class="hljs-keyword">while</span>( i-- &gt; <span class="hljs-number">0</span>) &#123;<br>			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br>			<span class="hljs-keyword">try</span> &#123;<br>				Thread.sleep(<span class="hljs-number">500</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
结果：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">t1 : <span class="hljs-number">4</span><br>t1 : <span class="hljs-number">3</span><br>t1 : <span class="hljs-number">2</span><br>t1 : <span class="hljs-number">1</span><br>t1 : <span class="hljs-number">0</span><br>t2 : <span class="hljs-number">4</span><br>t2 : <span class="hljs-number">3</span><br>t2 : <span class="hljs-number">2</span><br>t2 : <span class="hljs-number">1</span><br>t2 : <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问** object <strong>的一个</strong> synchronized(this) <strong>同步代码块时，它就获得了这个</strong> object <strong>的对象锁。结果，其它线程对该</strong> object **对象所有同步代码部分的访问都被暂时阻塞。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改 Thread2.m4t2() 方法如下：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4t2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>	<span class="hljs-keyword">while</span>( i-- &gt; <span class="hljs-number">0</span>) &#123;<br>		System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + i);<br>		<span class="hljs-keyword">try</span> &#123;<br>			Thread.sleep(<span class="hljs-number">500</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
结果：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada">t1 : 4<br>t1 : 3<br>t1 : 2<br>t1 : 1<br>t1 : 0<br>t2 : 4<br>t2 : 3<br>t2 : 2<br>t2 : 1<br>t2 : 0<br></code></pre></td></tr></table></figure>
五、以上规则对其它对象锁同样适用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread3</span> &#123;<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4t1</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>			<span class="hljs-keyword">while</span>(i-- &gt; <span class="hljs-number">0</span>) &#123;<br>				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : Inner.m4t1()=&quot;</span> + i);<br>				<span class="hljs-keyword">try</span> &#123;<br>					Thread.sleep(<span class="hljs-number">500</span>);<br>				&#125; <span class="hljs-keyword">catch</span>(InterruptedException ie) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4t2</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>			<span class="hljs-keyword">while</span>(i-- &gt; <span class="hljs-number">0</span>) &#123;<br>				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : Inner.m4t2()=&quot;</span> + i);<br>				<span class="hljs-keyword">try</span> &#123;<br>					Thread.sleep(<span class="hljs-number">500</span>);<br>				&#125; <span class="hljs-keyword">catch</span>(InterruptedException ie) &#123;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4t1</span><span class="hljs-params">(Inner inner)</span> &#123;<br>		<span class="hljs-keyword">synchronized</span>(inner) &#123; <span class="hljs-comment">//使用对象锁</span><br>			inner.m4t1();<br>	&#125;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4t2</span><span class="hljs-params">(Inner inner)</span> &#123;<br>		inner.m4t2();<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-keyword">final</span> <span class="hljs-type">Thread3</span> <span class="hljs-variable">myt3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread3</span>();<br>		<span class="hljs-keyword">final</span> <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> myt3.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>		<span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; myt3.m4t1(inner);&#125; &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>		<span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; myt3.m4t2(inner);&#125; &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>		t1.start();<br>		t2.start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
结果：尽管线程 t1 获得了对 Inner 的对象锁，但由于线程 t2 访问的是同一个 Inner 中的非同步部分。所以两个线程互不干扰。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">t1 : Inner.m4t1()=<span class="hljs-number">4</span><br>t2 : Inner.m4t2()=<span class="hljs-number">4</span><br>t1 : Inner.m4t1()=<span class="hljs-number">3</span><br>t2 : Inner.m4t2()=<span class="hljs-number">3</span><br>t1 : Inner.m4t1()=<span class="hljs-number">2</span><br>t2 : Inner.m4t2()=<span class="hljs-number">2</span><br>t1 : Inner.m4t1()=<span class="hljs-number">1</span><br>t2 : Inner.m4t2()=<span class="hljs-number">1</span><br>t1 : Inner.m4t1()=<span class="hljs-number">0</span><br>t2 : Inner.m4t2()=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
现在在** Inner.m4t2() <strong>前面加上</strong> synchronized**：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4t2</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>	<span class="hljs-keyword">while</span>(i-- &gt; <span class="hljs-number">0</span>) &#123;<br>		System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : Inner.m4t2()=&quot;</span> + i);<br>		<span class="hljs-keyword">try</span> &#123;<br>		Thread.sleep(<span class="hljs-number">500</span>);<br>		&#125; <span class="hljs-keyword">catch</span>(InterruptedException ie) &#123;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
结果：<br>尽管线程 t1 与 t2 访问了同一个 Inner 对象中两个毫不相关的部分，但因为 t1 先获得了对 Inner 的对象锁，所以 t2 对** Inner.m4t2() **的访问也被阻塞，因为 m4t2() 是 Inner 中的一个同步方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">t1 : Inner.m4t1()=<span class="hljs-number">4</span><br>t1 : Inner.m4t1()=<span class="hljs-number">3</span><br>t1 : Inner.m4t1()=<span class="hljs-number">2</span><br>t1 : Inner.m4t1()=<span class="hljs-number">1</span><br>t1 : Inner.m4t1()=<span class="hljs-number">0</span><br>t2 : Inner.m4t2()=<span class="hljs-number">4</span><br>t2 : Inner.m4t2()=<span class="hljs-number">3</span><br>t2 : Inner.m4t2()=<span class="hljs-number">2</span><br>t2 : Inner.m4t2()=<span class="hljs-number">1</span><br>t2 : Inner.m4t2()=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="40-this"><a href="#40-this" class="headerlink" title="40.this"></a>40.this</h2><blockquote>
<p>解释：这，这个<br>用法：指离它最近类的当前对象，他能够调用本类中的属性，方法，构造方法。需要注意的是在静态方法中不能使用** this **关键字。<br><strong>this</strong> 关键字用于引用当前实例。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br><span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span>&#123;<br><span class="hljs-built_in">this</span>.number = number;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>当引用可能不明确时，可以使用 this 关键字来引用当前的实例。<br>在上面的**-示例-<strong>中，构造方法参数 <strong>number</strong> 与类的成员变量同名。</strong>this.number** 明确表示 <strong>MyClass</strong> 的该实例的 <strong>number</strong> 成员变量。</p>
</blockquote>
<ol>
<li>在你的方法中的某个刑参名与当前对象的某个成员有相同的名字，这时为了不至于混淆，你便要明确使用 this 关键字来指明你要使用某个成员，使用方法是 this. 成员名，而不带 this 的那个便是刑参。另外，还可以用 this. 方法名来引用当前对象的某个方法，但这时** this **就不是必须的了，你可以直接用方法名来访问那个方法。</li>
<li>当父类的方法被重写后可以用** super <strong>来调用父类的方法。如果父类的方法可以被子类调用，那你可以象使用 this 一样使用它，用</strong> super. 父类中的成员名**的方式来调用。</li>
<li>**super <strong>和</strong> this <strong>直接在其后跟上适当的参数，因此它的意义就有了变化。</strong>super <strong>后加参数的是用来调用父类中具有相同形式的构造函数，</strong>this **后加参数则调用的是当前具有相同参数的构造函数。</li>
<li>**this <strong>通常指代当前对象，</strong>super **通常指带父类。</li>
</ol>
<h2 id="41-throw"><a href="#41-throw" class="headerlink" title="41.throw"></a>41.throw</h2><blockquote>
<p>解释：抛出，扔<br>用法：用户自己人为的抛出一个异常。可以让本没有异常的代码中出现一个人造的异常出来。既然自己抛出一个异常那就要自己负责到底，自己用 catch 块去将这个异常给捕捉。其语法格式如下：<strong>throw</strong> 异常对象。</p>
</blockquote>
<p>throw 关键字用于引发异常。<br><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>	<span class="hljs-keyword">public</span> method <span class="hljs-title function_">readFile</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">if</span> (error)&#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;error reading file&quot;</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>throw</strong> 语句将 <strong>java.lang.Throwable</strong> 作为参数。<strong>Throwable</strong> 在调用栈中向上传播，直到被适当的 <strong>catch</strong> 块捕获。<br>引发非 <strong>RuntimeException</strong> 异常的任何方法还必须在方法声明中使用 <strong>throws</strong> 修饰符来声明它引发的异常。</p>
</blockquote>
<h2 id="42-throws"><a href="#42-throws" class="headerlink" title="42.throws"></a>42.throws</h2><blockquote>
<p>解释：抛出，扔<br>用法：将方法体内产生的异常，自己不想再去负责捕捉，于是使用 throws 关键字将异常抛出方法体外部去。注意体内产生了什么类型的异常就应该抛出什么样的异常。并且抛出去之后总有一个人要负起这个责任，也就是谁调用了这个方法，谁去捕捉。<br><strong>throws</strong> 关键字可以应用于方法，以便指出方法引发了特定类型的异常。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>	<span class="hljs-keyword">public</span> method <span class="hljs-title function_">readFile</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">if</span> (error)&#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;error reading file&quot;</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>throws</strong> 关键字将逗号分隔的 <strong>java.lang.Throwables</strong> 列表作为参数。<br>引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 <strong>throws</strong> 修饰符来声明它引发的异常。<br>要在 <strong>try-catch</strong> 块中包含带 <strong>throws</strong> 子句的方法的调用，必须提供该方法的调用者。</p>
</blockquote>
<h2 id="43-transient"><a href="#43-transient" class="headerlink" title="43.transient"></a>43.transient</h2><blockquote>
<p>用法：transient 关键字可以应用于类的成员变量，以便指出该成员变量不应 在包含它的类实例已序列化时被序列化。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>java 语言的关键字，变量修饰符，如果用** transient <strong>声明一个实例变量，当对象存储时，它的值不需要维持。<br>Java 的</strong> serialization <strong>提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用</strong> serialization <strong>机制来保存它。为了在一个特定对象的一个域上关闭</strong> serialization<strong>，可以在这个域前加上关键字</strong> transient**。<br>**transient <strong>是 Java 语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，</strong>transient <strong>型变量的值不包括在串行化的表示中，然而非</strong> transient **型的变量是被包括进去的。</p>
</blockquote>
<h2 id="44-try"><a href="#44-try" class="headerlink" title="44.try"></a>44.try</h2><blockquote>
<p>解释：监视，考验，审问<br>用法：**try <strong>块用来监视所有又可能发生异常的代码，它可以和</strong> catch <strong>块组合，也可以和</strong> final <strong>块组合，也可以和</strong> catch <strong>块，</strong>final **块一起组合使用。<br><strong>try</strong> 关键字用于包含可能引发异常的语句块。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>&lt;可能引发异常的块&gt;<br>&#125;<br><span class="hljs-keyword">catch</span> (&lt;java.lang.Exception 或子类&gt; e)&#123;<br>&lt;处理异常 e 的代码&gt;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br>&lt;可能引发其他异常的块&gt;<br>&#125;<br><span class="hljs-keyword">catch</span> (FooException e)&#123;<br>&lt;处理 FooException e 的代码&gt;<br>&#125;<br><span class="hljs-keyword">catch</span> (BarException e)&#123;<br>&lt;处理 BarException e 的代码&gt;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br>&lt;可能引发异常的块&gt;<br>&#125;<br><span class="hljs-keyword">catch</span> (&lt;java.lang.Exception 或子类&gt; e)&#123;<br>&lt;处理异常 e 的代码&gt;<br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br>&lt;有异常或无异常情况下都执行的语句&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>-注释-</strong><br>每个 <strong>try</strong> 块都必须至少有一个 <strong>catch</strong> 或 **finally **子句。<br>如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 <strong>try</strong> 块。如果任何封闭 **try **块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。</p>
<h2 id="45-true"><a href="#45-true" class="headerlink" title="45.true"></a>45.true</h2><blockquote>
<p>解释：真，布尔型的字面值<br>用法：<strong>boolean <strong>类型的取值范围之一。<br><strong>true</strong> 关键字表示</strong> boolean</strong> 变量的两个合法值中的一个。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">isComplete</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<h2 id="46-void"><a href="#46-void" class="headerlink" title="46.void"></a>46.void</h2><blockquote>
<p>用法：<strong>void</strong> 关键字表示 <strong>null</strong> 类型。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>		&lt;statements&gt;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br><strong>void</strong> 可以用作方法的返回类型，以指示该方法不返回值。</p>
</blockquote>
<h2 id="47-volatile"><a href="#47-volatile" class="headerlink" title="47.volatile"></a>47.volatile</h2><blockquote>
<p>用法：<strong>volatile</strong> 关键字用于表示可以被多个线程异步修改的成员变量。<br>注意：<strong>volatile</strong> 关键字在许多 Java 虚拟机中都没有实现。</p>
</blockquote>
<p><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sharedValue;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-注释-<br>**volatile <strong>的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。<br><strong>Volatile <strong>修饰的成员变量在每次被线程访问时，都强迫从主内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>Java 语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。<br>这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。<br>而</strong> volatile <strong>关键字就是提示 VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。<br>使用建议：在两个或者更多的线程访问的成员变量上使用</strong> volatile</strong>。当要访问的变量已在</strong> synchronized <strong>代码块中，或者为常量时，不必使用。<br>由于使用</strong> volatile **屏蔽掉了 VM 中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p>
</blockquote>
<h2 id="48-while"><a href="#48-while" class="headerlink" title="48.while"></a>48.while</h2><p>用法：<strong>while</strong> 关键字用于指定一个只要条件为真就会重复的循环。<br><strong>-示例-</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!found)&#123;<br>	&lt;statements&gt;<br>&#125;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%9D%91/" class="category-chain-item">坑</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java 关键字总结</div>
      <div>https://bubao.github.io/posts/cefe6d2e.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>一念</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2016年7月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/7d3925ab.html" title="正则表达式笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">正则表达式笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/ac0f0b96.html" title="17.Java 异常处理">
                        <span class="hidden-mobile">17.Java 异常处理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"t6W6KmAoPXNvoRHvalIiqrVC-gzGzoHsz","appKey":"RTEVOUkcOQW24bsIRC0tIlUH","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":false,"serverURLs":"https://t6w6kmao.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appid":"t6W6KmAoPXNvoRHvalIiqrVC-gzGzoHsz","appkey":"RTEVOUkcOQW24bsIRC0tIlUH"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  




  <script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>





  <!-- Custom -->
  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/bubao" target="_blank" rel="nofollow noopener"><span>bubao</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div>
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
